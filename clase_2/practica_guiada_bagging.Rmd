---
title: "Ensambles - Clase 1"
author: "Diplomatura en Ciencias Sociales Computacionales"
date: '2023-02-06'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

final_tree <- readRDS('./model_decision_tree.RDS')
tree_res <- readRDS('./tree_tuning.RDS')

library(tidyverse)
library(tidymodels)
library(baguette)
library(rpart.plot)

```

Para la clase de hoy vamos a trabajar con los resultados de la Encuesta Nacional de Uso del Tiempo (2021). Vamos a tomar como insumo la variable `TCS_GRUPO_DOMESTICO` para construir una variable que define si las personas realizan trabajo doméstico en el hogar o no. `TCS_GRUPO_DOMESTICO` son los minutos totales dedicados a las actividades de trabajo doméstico en un día, independientemente de si se realizó otra actividad en simultáneo.

Vamos a tratar de predecir si las personas realizan o no trabajo doméstico en base al sexo, edad, la condición de actividad, la región, el nivel educativo, la relación con el/la jefe/a de hogar, la cantidad de demandantes de cuidado en el hogar, la cantidad de no demandantes de cuidado y si ese miembro del hogar es demandante o no de cuidado.

```{r}
data <- read_delim("../data/enut2021_base.txt", delim = "|")


data <- data %>% select(ID, SEXO_SEL, EDAD_SEL, TCS_GRUPO_DOMESTICO, CONDICION_ACTIVIDAD_AGRUPADA,   
                        NIVEL_EDUCATIVO_AGRUPADO, CANT_DEMANDANTES_TOTAL, CANT_NODEMANDANTES_TOTAL,
                        BHCH04_SEL, BHDC_SEL) %>% 
  mutate(realiza_domest = as.factor(case_when(
    TCS_GRUPO_DOMESTICO > 60 ~ "Realiza",
    TRUE ~ "No realiza")))
 
data <- data %>% mutate_at(
                   vars(SEXO_SEL), 
                    ~as.factor(case_when(
                      . == 1 ~ "Mujer",
                      . == 2 ~ "Varón"
                    )))
                   
 
 data <- data %>% mutate_at(vars(CONDICION_ACTIVIDAD_AGRUPADA), 
                   ~as.factor(case_when(
                     . == 1 ~ "Ocupado",
                     . == 2 ~ "No ocupado"
                   )))
 
data <- data %>% mutate_at(vars(BHCH04_SEL), 
                   ~as.factor(case_when(
                     . == 1 ~ "Jefe/a",
                     . == 2 ~ "Cónyuge/pareja",
                     . == 3 ~ "Hijo/a",
                     . == 4 ~ "Hijastro/a",
                     . == 5 ~ "Yerno/nuera",
                     . == 6 ~ "Nieto/a",
                     . == 7 ~ "Padre o madre",
                     . == 8 ~ "Suegro/a",
                     . == 9 ~ "Hermano/a",
                     . == 10 ~ "Cuñado/a",
                     . == 11 ~ "Sobrino/a",
                     . == 12 ~ "Abuelo/a",
                     . == 13 ~ "Otro familiar",
                     . == 14 ~ "Otro no familiar")))


 
 data <- data %>% mutate_at(vars(BHDC_SEL), 
                   ~as.factor(case_when(
                     . == 0 ~ "No es demandante de cuidado",
                     . == 1 ~ "Es demandante de cuidado"
                   )))
 

data <- data %>% select(-TCS_GRUPO_DOMESTICO)

```

Ahora, vamos a dividir en set de entrenamiento en train y test.

```{r}
set.seed(123)

split <- initial_split(data, strata = realiza_domest)
train <- training(split)
test <- testing(split)

table(test$realiza_domest)
```

A continuación, procesamos las variable haciendo la "receta" del modelo. Con `recipe()` especificamos un set de transformaciones que queremos hacer sobre el modelo. Su principal argumento es la fórmula del modelo, que en nuestro caso es `realiza_domest ~ .`

```{r}
recipe <- recipe(realiza_domest ~ ., data = train)%>%
  update_role(ID, new_role = "id") %>%
  step_other(BHCH04_SEL, threshold = 0.2)
```

A continuación, vamos a construir el `workflow()`de trabajo. Repasemos que en un workflow puedo juntar en preprocesamiento, modelado y funciones de post-modelado. Le agrego la receta que hicimos con `add_recipe`. 

```{r}
wf <- workflow() %>%
  add_recipe(recipe)
```

Ahora, vamos a armar y agregarle al workflow un árbol de decisión muy básico. Vamos a probar, ¿cómo funciona este modelo con un árbol de decisión simple?

```{r}
tree_spec <- decision_tree(  
  cost_complexity = tune(),
  tree_depth = tune(),
  min_n = tune()
) %>%
  set_engine("rpart") %>%
  set_mode("classification")

tree_spec %>% translate()
```
Hasta acá el modelo está "vacío", porque simplemente lo instanciamos pero no lo fiteamos. Lo vamos a hacer ahora, introduciéndolo en el workflow.

```{r}
tree_wf <- wf %>%
  add_model(tree_spec)
```


Pero primero, vamos a crear un grid de valores para probar en cada parámetro y hacer la validación con cross-fold. 

```{r}
set.seed(111)

folds <- vfold_cv(train, v = 10)

tidy(folds)

tree_grid <- grid_regular(cost_complexity(), tree_depth(), min_n(), levels = 4)

tree_grid%>% 
  count(tree_depth)
```

Tuneamos en el workflow los modelos con distintos parámetros... 

```{r eval=FALSE}

tree_res <- tree_wf %>%
  tune_grid(
    resamples = folds,
    grid = tree_grid
    )

```

¿Qué contiene este objeto?

```{r}
tree_res
```

Elegimos el árbol que tiene la mejor métrica de accuracy. 

```{r}
best_tree <- tree_res%>%
  select_best("accuracy")

best_tree
```

Por último, cerramos el workflow pasándole el modelo que tiene los mejores parámetros (best_tree) y vemos sus métricas para el entrenamiento. 

```{r}
tree_wf <- tree_wf %>% 
  finalize_workflow(best_tree)

tree_wf <- tree_wf %>%
  last_fit(split)

tree_wf%>% 
  collect_metrics()
```

Parece que tiene un buen accuracy, pero el área bajo la curva ROC es de 0,5. 

Probemos con el testing. Primero, hay que extraer el workflow con el árbol final para testear. 

```{r eval=FALSE}
final_tree <- extract_workflow(tree_wf)
```

Luego predecimos. 

```{r}
final_tree  %>% 
  predict(test) %>%
  bind_cols(test) %>%
  metrics(truth = realiza_domest, estimate = .pred_class)
```

```{r}
final_tree %>%
  predict(test) %>%
  bind_cols(test) %>%
  conf_mat(realiza_domest, .pred_class)
```

Incorporamos baguette

```{r}
tree_spec <- bag_tree() %>%
  set_engine("rpart", times = 5) %>%
  set_mode("classification")

```

```{r}
tree_bag <- wf %>%
  add_model(tree_spec) %>%
  fit(train)

tree_bag
```

```{r}
model_perfo_tree <- tree_bag %>%
  last_fit(split) %>% 
  collect_metrics()

model_perfo_tree
```

```{r}
preds <- tree_bag %>%
  last_fit(split) %>% 
  collect_predictions()

preds %>%
  metrics(realiza_domest, .pred_class)
```

```{r}
tree_bag %>%
  predict(test) %>%
  bind_cols(test) %>%
  conf_mat(realiza_domest, .pred_class)
```
